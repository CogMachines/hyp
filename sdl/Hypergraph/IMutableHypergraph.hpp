








#include <algorithm>








namespace Hypergraph {





























































  virtual StateId nextStateId() const = 0;























  // same as input.








     Add existing labels to new vocab, and setVocabulary(vocab).





  void takeVocabulary(IHypergraph<A> const& h) {
    this->setVocabulary(h.getVocabulary());
  }






















































/**


*/
template <class A>















 protected:




























 public:


  typedef IMutableHypergraph<A> Self;

  typedef A Arc;
  typedef typename A::Weight Weight;




















































  // for each Arc *arc, if keep(arc), then remap arc through x and
  // place it in the in/out arcs index. similar to HypergraphCopy.hpp
  // but in-place. note: if x.frozen, then keep is implicitly
  // heads+tails-in-x(arc) AND keep(arc)














    this->addProperties(kOutArcsSortedBestFirst);


































  template <class Arc, class SortPolicy>
  friend void sortArcsImpl(IMutableHypergraph<Arc>* hg, SortPolicy const& cmp);


















































  void clear(Properties prop) {













  void setEmptyIfNoArcs(bool addstart = true, bool addfinal = false) {

  }

  void setEmpty(bool addstart = false, bool addfinal = false) {
    clear();






    addProperties(kFsm);

  }















    Arc* a = new Arc(from, addState(label), w, to);





    Arc* a = new Arc(from, addState(EPSILON::ID), w, to);











    Arc* a = new Arc(from, addState(LabelPair(label, labelout)), w, to);





    Arc* a = new Arc(from, addState(inout), w, to);


  }






  // function overwrite with covariant return type:





  virtual void addArc(Arc*) = 0;



  void forceStoreArcs(bool outPreferred = true) {

  }




































    if (this->prunedEmpty()) {  // empty, who cares - any props are fine
      this->setEmpty();

      return;
    }





















        sortArcs(this);

















    }
















    }

  }







  virtual void removeOutArcs() = 0;






















  void projectInput() {
    removeOutputLabels();

  }













































    }






























  }

  void setPropertiesAt(Properties bits, bool on) {
    if (on)
      addProperties(bits);
    else
      clearProperties(bits);
  }



    clear();




  }




    clear();

    StateId f = this->addState();




  }














    template <class H, class SI>





};














































#endif
