
















#include <cassert>
#include <vector>















namespace Hypergraph {




















































    // assumes that kHasOutputLabels will be/has already been set to true



























  }









































      if (i.isTerminal())














































    return Util::getOrElse(lstate, io, kNoState);
































  }































































































































































    if (!x.stateAdding()) {








  typedef typename ArcsContainer::iterator ArcsIter;










        ArcsIter o = ias.begin();
        ArcsIter i = o, e = ias.end();





















            addArcFirstTailOut(a);



































































































































































    setNumStates((m == kNoState) ? 0 : m + 1);


























        forceFirstTailOutArcs();























































 protected:
  void init(Properties props) {







  }

 public:

  // improved: default props get set no matter what you pass in.





    copyHypergraph(*this, pHg);
    return pHg;
  }


    this->deleteArcs();  // can't go in parent classes
  }




















  }














  }





  }















































































  }
























  }




  }





  }



    if (!(properties_ & kCanonicalLex) || !input.isTerminal())
      return addStateImpl(input);





  }




    setNewStateLabels(state, input, output, properties_);



  StateId addState(LabelPair const& io) {
    return addState(input(io), output(io));
  }


  /// available.  Call only for axioms (terminal labels).

    assert(output == NoSymbol || input == output || input.isTerminal() && output.isTerminal());
    if (!(properties_ & kCanonicalLex)) return addStateNoCanonical(input, output);
    StateId* s;
    if (Util::update(lstate, LabelPair(input, output), s))
      return (*s = addStateNoCanonical(input, output));
    else
      return *s;
  }













  }






















  }

  /**


  */










      StateId s = (m == kNoState) ? 0 : m + 1;





























    return kNoState;


































  }





  }



    this->clearProperties(kStoreOutArcs);






  }




    if (!IHypergraph<Arc>::checkValid()) return false;
    if (this->prunedEmpty()) return true;
    if (this->isFsm() && !this->isFsmCheck()) {


    }
    return true;
  }

 private:


  void addArcIn(Arc* arc) {


  }









  void addArcOut(Arc* arc) {




  }










    AddFirstTailOut(Self& hg) : hg(hg) {}








































 public:








  /**



  */



















  }































  }









    }

  }








































  }
















  }







    assert(storesInArcs());

  }



  }





  // The in and out arcs are not in a separate State class because
  // then every state would have such vectors of in and out
  // arcs. Sometimes we do not store in arcs, for example, at all, and
  // will have just one empty vector now.


};




#endif
